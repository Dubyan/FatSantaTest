<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flappy Bird</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  overflow: hidden;
}
#canvas {
  width: 100%;
  height: 100%;
  background-color: skyblue;
  display: block;
}
#back-button {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 10;
  background-color: rgba(255, 255, 255, 0.8);
  border: none;
  border-radius: 5px;
  padding: 5px 10px;
  cursor: pointer;
}
#start-button {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 10;
  background-color: rgba(0, 255, 0, 0.8);
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  cursor: pointer;
  font-size: 16px;
  display: block; /* Initially visible */
}
</style>
</head>
<body>
<button id="back-button" onclick="window.location.href='index.html';">Назад</button>
<button id="start-button" onclick="startGame()">Старт</button>
<canvas id="canvas"></canvas>
<script>
"use strict";

const cvs = document.getElementById("canvas");
cvs.width = window.innerWidth;
cvs.height = window.innerHeight;
const ctx = cvs.getContext("2d");

const gap = 150; // Distance between top and bottom pipes
let bX = 50;     // Bird's x-coordinate
let bY = cvs.height / 2; // Bird's y-coordinate
let birdVelocity = 0;   // Bird's vertical velocity
const gravity = 0.6;    // Gravitational acceleration
let score = 0;         // Game score
let birdSize = 20;     // Bird's size
let pipeWidth = 50;    // Pipe width
let pipeDistance = 300; // Minimum distance between pipes
let lastFrameTime = performance.now(); // Time of the last frame
let gameStartTime = 0;  // Game start time
const jumpHeight = -8;  // Vertical jump speed
const horizontalSpeed = 3; // Horizontal pipe speed
let gameStarted = false; // Flag to indicate game start
let gameOver = false;   // Flag to indicate game over

const pipe = [];       // Array to store pipe objects

// Function to draw a single pipe
function drawPipe(pipe) {
    const pipeTop = pipe.y;
    const pipeBottom = pipeTop + pipe.gap;
    ctx.fillStyle = "grey";
    ctx.fillRect(pipe.x, 0, pipeWidth, pipeTop);
    ctx.fillRect(pipe.x, pipeBottom, pipeWidth, cvs.height - pipeBottom);
}

// Function to draw the bird
function drawBird() {
    ctx.fillStyle = "red";
    ctx.fillRect(bX, bY, birdSize, birdSize);
}

// Function to create a new pipe
function createPipe() {
    const pipeTop = Math.random() * (cvs.height - 2 * gap - 20) + gap;
    pipe.push({
        x: cvs.width,
        y: pipeTop,
        gap: gap,
        scored: false // Flag to prevent double scoring
    });
}

// Function to check for collisions
function checkCollision(pipe) {
    const birdRect = { x: bX, y: bY, width: birdSize, height: birdSize };
    const topPipeRect = { x: pipe.x, y: 0, width: pipeWidth, height: pipe.y };
    const bottomPipeRect = { x: pipe.x, y: pipe.y + pipe.gap, width: pipeWidth, height: cvs.height - (pipe.y + pipe.gap) };

    function intersects(rectA, rectB) {
        return (
            rectA.x < rectB.x + rectB.width &&
            rectA.x + rectA.width > rectB.x &&
            rectA.y < rectB.y + rectB.height &&
            rectA.height + rectA.y > rectB.y
        );
    }

    return intersects(birdRect, topPipeRect) || intersects(birdRect, bottomPipeRect) || bY + birdSize > cvs.height - 20;
}

// Function to check if the bird passed a pipe
function checkScore(pipe) {
    if (bX > pipe.x + pipeWidth && !pipe.scored) {
        score++;
        pipe.scored = true;
    }
}

// Main game loop
function draw(currentTime) {
    const deltaTime = (currentTime - lastFrameTime) / 1000;
    lastFrameTime = currentTime;

    if (gameOver) {
        alert("Game Over! Your score: " + score + " seconds");
        location.reload();
        return;
    }

    ctx.clearRect(0, 0, cvs.width, cvs.height);
    ctx.fillStyle = "skyblue";
    ctx.fillRect(0, 0, cvs.width, cvs.height);

    if (gameStarted) {
        // Pipe generation and movement
        if (pipe.length === 0) {
            createPipe();
        }
        if (pipe.length > 0) {
            while (pipe[pipe.length - 1].x < cvs.width - pipeDistance) {
                createPipe();
            }
            for (let i = 0; i < pipe.length; i++) {
                drawPipe(pipe[i]);
                pipe[i].x -= horizontalSpeed * 60 * deltaTime;
                if (pipe[i].x + pipeWidth < 0) {
                    pipe.shift();
                }
                if (checkCollision(pipe[i])) {
                    gameOver = true;
                }
                checkScore(pipe[i]);
            }
        }

        // Bird movement and drawing
        birdVelocity += gravity * 60 * deltaTime;
        bY += birdVelocity * deltaTime;
        drawBird();

        // Ground
        ctx.fillStyle = "green";
        ctx.fillRect(0, cvs.height - 20, cvs.width, 20);

        // Score display
        ctx.fillStyle = "#000";
        ctx.font = "20px Verdana";
        if (gameStartTime) {
            score = Math.floor((currentTime - gameStartTime) / 1000);
            ctx.fillText("Time: " + score + " seconds", 10, cvs.height - 20);
        }
    }

    requestAnimationFrame(draw);
}

// Function to handle bird jump (triggered by touch or spacebar)
function moveUp() {
    birdVelocity = jumpHeight;
}

document.addEventListener('touchstart', moveUp);
document.addEventListener('keydown', (event) => {
    if (event.code === 'Space') {
        moveUp();
    }
});

// Function to start the game
function startGame() {
    gameStarted = true;
    gameStartTime = performance.now();
    document.getElementById("start-button").style.display = "none";
}

requestAnimationFrame(draw); // Start the animation loop
</script>
</body>
</html>
