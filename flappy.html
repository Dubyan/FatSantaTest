<!DOCTYPE html>
<html>
<head>
<title>Flappy Bird</title>
<style>
body { margin: 0; overflow: hidden; }
#canvas { width: 100vw; height: 100vh; display: block; }
#start-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #4CAF50;
    border: none;
    padding: 10px 20px;
    cursor: pointer;
    display: block; /* Initially visible */
}
#back-button {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: #f0f0f0;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
}
</style>
</head>
<body>
<button id="back-button" onclick="window.location.href='index.html';">Назад</button>
<button id="start-button" onclick="startGame()">Старт</button>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let devicePixelRatio = window.devicePixelRatio || 1;
canvas.width = window.innerWidth * devicePixelRatio;
canvas.height = window.innerHeight * devicePixelRatio;
ctx.scale(devicePixelRatio, devicePixelRatio);


const gravity = 0.5;
const birdSize = 20;
const jumpHeight = -10;
const pipeWidth = 50;
const pipeGap = 150;
const pipeSpeed = 2;

let birdX = 50;
let birdY = canvas.height / 2;
let birdVelocity = 0;
let score = 0;
let gameStarted = false;
let gameOver = false;
let lastFrameTime = performance.now();

const pipes = [];

function drawBird() {
  ctx.fillStyle = 'red';
  ctx.fillRect(birdX, birdY, birdSize, birdSize);
}

function createPipe() {
  const pipeTop = Math.random() * (canvas.height - pipeGap - 100) + 50;
  pipes.push({
    x: canvas.width,
    top: pipeTop,
    bottom: pipeTop + pipeGap,
    scored: false
  });
}

function drawPipes() {
  ctx.fillStyle = 'grey';
  for (let i = pipes.length - 1; i >= 0; i--) {
    const pipe = pipes[i];
    ctx.fillRect(pipe.x, 0, pipeWidth, pipe.top);
    ctx.fillRect(pipe.x, pipe.bottom, pipeWidth, canvas.height - pipe.bottom);
    pipe.x -= pipeSpeed;
    if (pipe.x + pipeWidth < 0) {
      pipes.shift();
    }
    if (detectCollision(pipe)) {
      gameOver = true;
    }
    if (pipe.x + pipeWidth < birdX && !pipe.scored) {
      score++;
      pipe.scored = true;
    }
  }
}

function detectCollision(pipe) {
  return (
    birdX < pipe.x + pipeWidth &&
    birdX + birdSize > pipe.x &&
    (birdY < pipe.top || birdY + birdSize > pipe.bottom) ||
    birdY + birdSize > canvas.height
  );
}

function drawScore() {
  ctx.fillStyle = 'black';
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${score}`, 10, 30);
}

function update(currentTime) {
  const deltaTime = (currentTime - lastFrameTime) / 1000;
  lastFrameTime = currentTime;

  if (gameOver) {
    alert("Game Over! Your score: " + score);
    gameStarted = false;
    document.getElementById('start-button').style.display = 'block';
    return;
  }

  if (gameStarted) {
    birdVelocity += gravity * deltaTime * 60;
    birdY += birdVelocity * deltaTime;

    if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 300) {
      createPipe();
    }
    drawPipes();
    drawBird();
    drawScore();
  }

  requestAnimationFrame(update);
}


function jump() {
  birdVelocity = jumpHeight;
}

canvas.addEventListener('touchstart', jump);
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    jump();
  }
});

function startGame() {
  gameStarted = true;
  document.getElementById('start-button').style.display = 'none';
  birdY = canvas.height / 2;
  birdVelocity = 0;
  pipes.length = 0;
  score = 0;
  gameOver = false;
}

requestAnimationFrame(update);
</script>
</body>
</html>
